"""
Generated by CHARMM-GUI (http://www.charmm-gui.org)

psf2itp.py

This program is for GROMACS input generation with CHARMM36 FF.

Correspondance: jul316@lehigh.edu or wonpil@lehigh.edu
Last update: October 31, 2019

### -*- coding: utf-8 -*-
"""


from __future__ import print_function
import sys, os, argparse, math

# conversion constant between kcal and kJ
kcal2kJ = 4.184

# specification of character used for comments in charmm ff file
comment = '!'

# dictionary for atom numbers, used for the nb file
elem2atomNumber = dict([('LP',  0), ( 'H',  1), ('HE',  2), ('LI',  3), ('BE',  4),
                        ( 'B',  5), ( 'C',  6), ( 'N',  7), ( 'O',  8), ( 'F',  9),
                        ('NE', 10), ('NA', 11), ('MG', 12), ('AL', 13), ('SI', 14),
                        ( 'P', 15), ( 'S', 16), ('CL', 17), ( 'K', 19), ('CA', 20),
                        ('SC', 21), ('TI', 22), ( 'V', 23), ('CR', 24), ('MN', 25),
                        ('FE', 26), ('CO', 27), ('NI', 28), ('CU', 29), ('ZN', 30),
                        ('GA', 31), ('SE', 34), ('BR', 35), ('RB', 37), ('SR', 38),
                        ( 'Y', 39), ('RH', 45), ('PD', 46), ('AG', 47), ('CD', 48),
                        ('IN', 49), ('SN', 50), ( 'I', 53), ('CS', 55), ('BA', 56),
                        ('LA', 57), ('CE', 58), ('PR', 59), ('ND', 60), ('PM', 61),
                        ('SM', 62), ('EU', 63), ('GD', 64), ('TB', 65), ('DY', 66),
                        ('HO', 67), ('ER', 68), ('TM', 69), ('YB', 70), ('LU', 71),
                        ('PT', 78), ('AU', 79), ('HG', 80), ('TL', 81), ('PB', 82),
                        ('BI', 83), ('RA', 88), ( 'U', 92), ('PU', 94)])

mass2elem = dict([(  '0.0', 'LP'), (  '1.0',  'H'), (  '4.0', 'HE'), (  '6.9', 'LI'), (  '9.0', 'BE'),
                  ( '10.8',  'B'), ( '12.0',  'C'), ( '14.0',  'N'), ( '16.0',  'O'), ( '19.0',  'F'),
                  ( '20.2', 'NE'), ( '23.0', 'NA'), ( '24.3', 'MG'), ( '27.0', 'AL'), ( '28.1', 'SI'),
                  ( '31.0',  'P'), ( '32.1',  'S'), ( '35.5', 'CL'), ( '39.1',  'K'), ( '40.1', 'CA'),
                  ( '45.0', 'SC'), ( '47.9', 'TI'), ( '50.9',  'V'), ( '52.0', 'CR'), ( '54.9', 'MN'),
                  ( '55.8', 'FE'), ( '58.9', 'CO'), ( '58.7', 'NI'), ( '63.5', 'CU'), ( '65.4', 'ZN'),
                  ( '69.7', 'GA'), ( '79.0', 'SE'), ( '79.9', 'BR'), ( '85.5', 'RB'), ( '87.6', 'SR'),
                  ( '88.9',  'Y'), ('102.9', 'RH'), ('106.4', 'PD'), ('107.9', 'AG'), ('112.4', 'CD'),
                  ('114.8', 'IN'), ('118.7', 'SN'), ('126.9',  'I'), ('132.9', 'CS'), ('137.3', 'BA'),
                  ('138.9', 'LA'), ('140.1', 'CE'), ('140.9', 'PR'), ('144.2', 'ND'), ('144.9', 'PM'),
                  ('150.4', 'SM'), ('152.0', 'EU'), ('157.3', 'GD'), ('158.9', 'TB'), ('162.5', 'DY'),
                  ('164.9', 'HO'), ('167.3', 'ER'), ('168.9', 'TM'), ('173.1', 'YB'), ('175.0', 'LU'),
                  ('195.1', 'PT'), ('197.0', 'AU'), ('200.6', 'HG'), ('204.4', 'TL'), ('207.2', 'PB'),
                  ('209.0', 'BI'), ('226.0', 'RA'), ('238.0',  'U'), ('244.1', 'PU'),
                  ('96.0', 'MO'), ('227.0', 'AC'), ('252.0', 'ES'), ('192.2', 'IR'), ('232.0', 'TH'), ('173.0', 'YB')]) #tanmoy 060521
                  #tanmoy : add more elements' (atomic wt, symbol) pair as they are being added to par_interface.prm

class TOPPAR:
    def __init__(self, toppar_str):
        ext2type = {'rtf': 'top', 'prm': 'par', 'str': 'str'}
        self.toppar_list = {'top': [], 'par': [], 'str': [], 'all': []}

        # output paramter file names to server
        for line in open(toppar_str, 'r'):
            if comment in line: line = line.split(comment)[0]
            line = line.strip()
            if line.upper().startswith('OPEN') or line.upper().startswith('STREAM'):
                filename = line.split()[-1]
                ext = filename.lower().split('.')[-1]
                if not ext in list(ext2type.keys()): continue
                self.toppar_list[ext2type[ext]].append(filename)
                self.toppar_list['all'].append(filename)

        if len(self.toppar_list['all']) == 0:
            print("Fatal error: incorrect path for toppar.str")
            exit()

        self.index2type = dict()
        self.params = dict(atoms=dict(), bonds=dict(), angles=dict(), dihedrals=dict(), impropers=dict(),
                           nonbonded=dict(), nb14=dict(), nbfix=dict(), cmap=[])
        self.wationlib = []

    def readToppar(self):
        toppar_flag = dict(RESI=None, PRES=None, ATOMS='atom', BONDS='bond', ANGLES='angle', DIHEDRALS='dihedral',
                           IMPROPER='improper', CMAP='cmap', NONBONDED='nonbonded', NBFIX='nbfix', HBOND=None, END=None)
        wation_toppar = ['toppar/toppar_water_ions.str', 'toppar/toppar_ions_won.str']

        attype_index = 1
        for topparfile in self.toppar_list['all']:
            readprm = None
            line_continue = None
            for line in open(topparfile, 'r'):
                if line.find(comment) >= 0: line = line.split(comment)[0]
                line = line.upper().strip()
                if not line: continue

                if line_continue:
                    line = line_continue + line
                    line_continue = None
                if line.endswith('-'):
                    line_continue = line[:-1]
                    continue

                is_flag = False
                for flag in toppar_flag:
                    if line.startswith(flag):
                        if flag == 'CMAP' and not line.endswith(flag): break
                        is_flag = True
                        readprm = toppar_flag[flag]
                        if flag == 'RESI' and topparfile in wation_toppar:
                            self.wationlib.append(line.split()[1])
                        break

                if is_flag: continue
                if line.startswith('RETURN'): break
                if not readprm: continue

                segments = line.split()

                if readprm == 'atom':
                    attype = segments[2]
                    atmass = float(segments[3])
                    if attype in self.params['atoms']: continue     # skip duplicated atom type
                    self.params['atoms'][attype] = dict(mass=atmass, elem=mass2elem[str(int(atmass*10.0+0.5)/10.0)], charge=0.0)
                    if segments[1] == '-1':
                        self.index2type[str(attype_index)] = attype
                        attype_index += 1
                    else:
                        self.index2type[segments[1]] = attype

                if readprm == 'bond':
                    type1 = segments[0]
                    type2 = segments[1]
                    b0 = float(segments[3])
                    Kb = float(segments[2])
                    b0 = float(b0)/10        # conversion from A -> nm
                    Kb = Kb*2*kcal2kJ*1000/10    # converstion from kcal/mole/A**2 -> kJ/mole/nm**2 incl factor 2 (see definitions)
                    if (type2, type1) in self.params['bonds']: del self.params['bonds'][type2, type1]     # remove duplicated parameters
                    self.params['bonds'][type1, type2] = [b0, Kb]

                if readprm == 'angle':
                    type1 = segments[0]
                    type2 = segments[1]
                    type3 = segments[2]
                    th0 = float(segments[4])
                    cth = float(segments[3])
                    cth = cth*2*kcal2kJ        # kJ/mol and an factor 2 (see definitions)
                    if len(segments)>6:        # check for Urey-Bradley parameters
                        try:
                            S0  = float(segments[6])
                            Kub = float(segments[5])
                            S0  = S0/10
                            Kub = Kub*2*kcal2kJ*1000/10
                            ubFlag = True
                        except ValueError:
                            ubFlag = False
                    else:
                        ubFlag = False
                    if not ubFlag:
                        S0  = 0.0
                        Kub = 0.0
                    if (type3, type2, type1) in self.params['angles']: del self.params['angles'][type3, type2, type1]     # remove duplicated parameters
                    self.params['angles'][type1, type2, type3] = [th0, cth, S0, Kub]

                if readprm == 'dihedral':
                    type1 = segments[0]
                    type2 = segments[1]
                    type3 = segments[2]
                    type4 = segments[3]
                    phi0 = float(segments[6])
                    cp   = float(segments[4])
                    mult = int(segments[5])
                    cp   = cp*kcal2kJ            # conversion to kJ
                    if (type1, type2, type3, type4) in self.params['dihedrals']:
                        for imult, dihedral in enumerate(self.params['dihedrals'][type1, type2, type3, type4]):
                            if dihedral[2] == mult: del self.params['dihedrals'][type1, type2, type3, type4][imult]
                        self.params['dihedrals'][type1, type2, type3, type4].append([phi0, cp, mult])
                    elif (type4, type3, type2, type1) in self.params['dihedrals']:
                        for imult, dihedral in enumerate(self.params['dihedrals'][type4, type3, type2, type1]):
                            if dihedral[2] == mult: del self.params['dihedrals'][type4, type3, type2, type1][imult]
                        self.params['dihedrals'][type4, type3, type2, type1].append([phi0, cp, mult])
                    else:
                        self.params['dihedrals'][type1, type2, type3, type4] = [[phi0, cp, mult]]

                if readprm == 'improper':
                    type1 = segments[0]
                    type2 = segments[1]
                    type3 = segments[2]
                    type4 = segments[3]
                    q0 = float(segments [6])
                    cq = float(segments [4])
                    cq = cq*2*kcal2kJ        # conversion to kJ, factor 2 from definition difference
                    self.params['impropers'][type1, type2, type3, type4] = [q0, cq]

                if readprm == 'cmap':
                    try:
                        segments[0] = float(segments[0])
                        for icmap in segments:
                            icmap = float(icmap)*kcal2kJ
                            self.params['cmap'][-1]['data'].append(icmap)
                    except:
                        type1 = segments[0]
                        type2 = segments[1]
                        type3 = segments[2]
                        type4 = segments[3]
                        type5 = segments[7]
                        ncmap = int(segments[8])
                        self.params['cmap'].append(dict(atoms=[type1, type2, type3, type4, type5], ncmap=ncmap, data=[]))

                if readprm == 'nonbonded':
                    attype   = segments[0]
                    epsilon  = float(segments[2])
                    RminHalf = float(segments[3])
                    eps      = abs(epsilon*kcal2kJ)        # conversion to kJ and positive
                    sigma    = 2*RminHalf/(10.0*2.0**(1.0/6.0))    # -> nm, double distance and rmin2sigma factor
                    self.params['nonbonded'][attype] = [sigma, eps]
                    if len(segments)> 6:        # test length to avoid IndexError
                        try:            # if possible, convert element 5 to float
                            segments[5] = float(segments[5])
                        except:
                            None
                        # is segment 5 and 6 floats => there's 1-4 defined
                        if not isinstance(segments[5],str): # not string?
                            epsilon14  = float(segments[5])            # read charmm epsilon
                            eps14      = abs(epsilon14*kcal2kJ)        # conversion to gromacs units
                            Rmin14Half = float(segments[6])            # read charmm Rmin*1/2
                            sigma14    = 2*Rmin14Half/(10.0*2.0**(1.0/6.0))    # conversion to gromacs units
                            self.params['nb14'][attype] = [sigma14, eps14]        # add to list

                if readprm == 'nbfix':
                    type1 = segments[0]
                    type2 = segments[1]
                    epsilon = float(segments[2])
                    Rmin    = float(segments[3])
                    eps     = abs(epsilon*kcal2kJ)        # conversion to kJ and positive
                    sigma   = Rmin/(10.0*2.0**(1.0/6.0))    # -> nm, double distance and rmin2sigma factor
                    if (type2, type1) in self.params['nbfix']: del self.params['nbfix'][type2, type1]     # remove duplicated parameters
                    self.params['nbfix'][type1, type2] = [sigma, eps]

class PSF:
    def __init__(self, psfFile):
        self.psfFile = open(psfFile, 'r')

        self.mol   = []
        self.memb  = []
        self.glip  = []
        self.solv  = []
        self.types = []

        self.ndx   = [[] for i in range(3)]

        self.atoms     = []
        self.bonds     = []
        self.angles    = []
        self.dihedrals = []
        self.impropers = []
        self.grps      = []
        self.lonepairs = []
        self.cmaps     = []

        self.molNumber = dict()

    def readPSF(self, toppar):
        psf_flag = dict(NAT='atom', NBO='bond', NTH='angle', NPH='dihedral', NIM='improper',
                        NDO=None, NAC=None, NNB=None, NGR='group', MOL=None, NCR='cmap')

        molinfo   = []
        readpsf = None

        for line in self.psfFile:
            line = line.upper().strip()
            if not line: continue

            if line.startswith('PSF'):
                xplor = 'XPLOR' in line
                continue

            is_flag = False
            if comment in line:
                flag = line.split(comment)[1].strip()[:3]
                if flag in psf_flag:
                    is_flag = True
                    readpsf = psf_flag[flag]
            if is_flag: continue
            if line.endswith('NUMLPH'): readpsf = 'lonepair'
            if not readpsf: continue

            segments = line.split()

            if readpsf == 'atom':
                atomid   = int(segments[0])
                segid    = segments[1]
                resid    = segments[2]
                resname  = segments[3]
                atomname = segments[4]
                atomtype = segments[5]
                atomchrg = float(segments[6])
                atommass = float(segments[7])

                attype = atomtype if xplor else toppar.index2type[atomtype]
                molname = segid
                if segid == 'MEMB': molname = resname

                if molname in self.mol:
                    imol = self.mol.index(molname)
                else:
                    self.mol.append(molname)
                    self.molNumber[molname] = 1
                    molinfo.append({'firstres': resid, 'firstatom': atomname, 'firstatomid': atomid, 'natom': 0})

                    if segid == 'MEMB':   self.memb.append(molname)
                    if resname == 'TIP3': self.solv.append(molname)
                    if molname[:3] in ['GLP', 'LPS']: self.glip.append(molname)

                    self.atoms.append([])
                    self.bonds.append([])
                    self.angles.append([])
                    self.dihedrals.append([])
                    self.impropers.append([])
                    self.grps.append([])
                    self.lonepairs.append([])
                    self.cmaps.append([])

                    imol = len(self.mol) - 1

                if (resname in toppar.wationlib and (resname == segid or resname == 'TIP3')) or segid == 'MEMB':
                    if ( resid != molinfo[imol]['firstres'] or self.molNumber[molname] != 1 ) \
                    and atomname == molinfo[imol]['firstatom']:
                        self.molNumber[molname] += 1

                if self.molNumber[molname] == 1:
                    self.atoms[imol].append({'type': attype, 'resnr': resid, 'residu': resname,
                                             'atom': atomname, 'charge': atomchrg, 'mass': atommass})
                    self.bonds[imol].append([])
                    molinfo[imol]['natom'] += 1

                if not attype in self.types:
                    self.types.append(attype)
                    toppar.params['atoms'][attype]['charge'] = atomchrg

                if segid == 'MEMB' or segid in self.glip:
                    self.ndx[1].append(atomid)
                elif resname in toppar.wationlib:
                    self.ndx[2].append(atomid)
                else:
                    self.ndx[0].append(atomid)

            if readpsf == 'bond':
                for i in range(0, len(segments), 2):
                    atom1 = int(segments[i])
                    atom2 = int(segments[i+1])
                    for imol in range(len(self.mol)):
                        fatom = molinfo[imol]['firstatomid']
                        natom = molinfo[imol]['natom']
                        latom = fatom + natom - 1
                        if all(fatom <= atom <= latom for atom in [atom1, atom2]):
                            self.bonds[imol][atom1-fatom].append(atom2-fatom)
                            self.bonds[imol][atom2-fatom].append(atom1-fatom)
                            break

            if readpsf == 'angle':
                for i in range(0, len(segments), 3):
                    atom1 = int(segments[i])
                    atom2 = int(segments[i+1])
                    atom3 = int(segments[i+2])
                    for imol in range(len(self.mol)):
                        fatom = molinfo[imol]['firstatomid']
                        natom = molinfo[imol]['natom']
                        latom = fatom + natom - 1
                        if all(fatom <= atom <= latom for atom in [atom1, atom2, atom3]):
                            self.angles[imol].append([atom-fatom+1 for atom in [atom1, atom2, atom3]])
                            break

            if readpsf == 'dihedral':
                for i in range(0, len(segments), 4):
                    atom1 = int(segments[i])
                    atom2 = int(segments[i+1])
                    atom3 = int(segments[i+2])
                    atom4 = int(segments[i+3])
                    for imol in range(len(self.mol)):
                        fatom = molinfo[imol]['firstatomid']
                        natom = molinfo[imol]['natom']
                        latom = fatom + natom - 1
                        if all(fatom <= atom <= latom for atom in [atom1, atom2, atom3, atom4]):
                            self.dihedrals[imol].append([atom-fatom+1 for atom in [atom1, atom2, atom3, atom4]])
                            break

            if readpsf == 'improper':
                for i in range(0, len(segments), 4):
                    atom1 = int(segments[i])
                    atom2 = int(segments[i+1])
                    atom3 = int(segments[i+2])
                    atom4 = int(segments[i+3])
                    for imol in range(len(self.mol)):
                        fatom = molinfo[imol]['firstatomid']
                        natom = molinfo[imol]['natom']
                        latom = fatom + natom - 1
                        if all(fatom <= atom <= latom for atom in [atom1, atom2, atom3, atom4]):
                            self.impropers[imol].append([atom-fatom+1 for atom in [atom1, atom2, atom3, atom4]])
                            break

            if readpsf == 'group':
                for i in range(0, len(segments), 3):
                    atom1 = int(segments[i]) + 1
                    for imol in range(len(self.mol)):
                        fatom = molinfo[imol]['firstatomid']
                        natom = molinfo[imol]['natom']
                        latom = fatom + natom - 1
                        if fatom <= atom1 <= latom:
                            self.grps[imol].append(atom1-fatom+1)
                            break

            if readpsf == 'lonepair':
                numlp = int(segments[0])
                numlph = int(segments[1])
                lp_info = []
                for i in range(numlp):
                    line = next(self.psfFile)
                    line = line.strip()
                    segments = line.split()

                    nhost    = int(segments[0])
                    lp_index = int(segments[1])
                    lp_type  = segments[2]
                    d   = float(segments[3]) / 10.0
                    th0 = float(segments[4])
                    phi = float(segments[5])

                    lp_info.append({'nhost': nhost, 'lp_index': lp_index, 'lp_type': lp_type, 'd': d, 'th0': th0, 'phi': phi})

                nlpline = int(math.ceil(numlph / 8.0))
                lp_atoms = []
                for i in range(nlpline):
                    line = next(self.psfFile)
                    line = line.strip()
                    lp_atoms += [int(atom) for atom in line.split()]

                for lp in lp_info:
                    nhost = lp['nhost']
                    lp_index = lp['lp_index']
                    lp_hosts = lp_atoms[lp_index-1:lp_index+nhost]
                    for imol in range(len(self.mol)):
                        fatom = molinfo[imol]['firstatomid']
                        natom = molinfo[imol]['natom']
                        latom = fatom + natom - 1
                        if all(fatom <= atom <= latom for atom in lp_hosts):
                            lp['atoms'] = [atom-fatom for atom in lp_hosts]
                            self.lonepairs[imol].append(lp)
                            break

            if readpsf == 'cmap':
                atom1 = int(segments[0])
                atom2 = int(segments[1])
                atom3 = int(segments[2])
                atom4 = int(segments[3])
                atom5 = int(segments[7])
                for imol in range(len(self.mol)):
                    fatom = molinfo[imol]['firstatomid']
                    natom = molinfo[imol]['natom']
                    latom = fatom + natom - 1
                    if all(fatom <= atom <= latom for atom in [atom1, atom2, atom3, atom4, atom5]):
                        self.cmaps[imol].append([atom-fatom+1 for atom in [atom1, atom2, atom3, atom4, atom5]])
                        break

    def HydrogenMassRepartition(self, toppar):
        # molecule.itp
        for imol, molname in enumerate(self.mol):
            if molname in self.solv: continue
            for index1, bond in enumerate(self.bonds[imol]):
                atom1 = self.atoms[imol][index1]
                elem1 = toppar.params['atoms'][atom1['type']]['elem']
                for index2 in bond:
                    if index2 < index1: continue
                    atom2 = self.atoms[imol][index2]
                    elem2 = toppar.params['atoms'][atom2['type']]['elem']
                    if not 'H' in [elem1, elem2]: continue
                    if elem1 == 'H': hmr1, hmr2 = atom1, atom2
                    else:            hmr1, hmr2 = atom2, atom1
                    old_mass = hmr1['mass']
                    hmr1['mass'] = hmr1['mass'] * 3.0
                    hmr2['mass'] = hmr2['mass'] - hmr1['mass'] + old_mass

def write_itp(toppar, psf):

    # set the func parameter for bonds, angles and proper/improper dihedrals
    # for further information see section 5.7.1 in gromacs documentation:
    # ftp://ftp.gromacs.org/pub/manual/manual-4.6.5.pdf

    funcForBonds     = 1
    funcForAngles    = 5    # Urey-Bradley angle type
    funcForDihedrals = 9    # special type for treating multiple entries (modification in source code)
    funcForImpropers = 2
    funcFor14        = 1    # 1-4 interaction pair type
    funcForCmap      = 1
    funcForLonepairs = 3
    funcForExclusions = 1

    # particle type
    ptype = 'A'

    # Build DataBase
    #------------------------------

    psf.types.sort()

    dbbonds     = []
    dbpairs     = []
    dbnbfix     = []
    dbangles    = []
    dbdihedrals = []
    dbdihewilds = []
    dbimpropers = []
    dbimprwilds = []
    dbcmap      = []

    # bondtypes
    for bond in toppar.params['bonds']:
        type1 = bond[0]
        type2 = bond[1]
        if type1 in psf.types and type2 in psf.types:
            b0 = toppar.params['bonds'][type1,type2][0]
            Kb = toppar.params['bonds'][type1,type2][1]
            dbbonds.append([type1,type2,b0,Kb])

    # pairtypes
    for i in range(len(psf.types)):
        for j in range(i,len(psf.types)):
            type1 = psf.types[i]
            type2 = psf.types[j]
            ipair = jpair = False
            if not ((type1, type2) in toppar.params['nbfix'] or (type2, type1) in toppar.params['nbfix']):
                if type1 in toppar.params['nb14']:
                    isigma14, ieps14 = toppar.params['nb14'][type1]
                    ipair    = True
                else:
                    isigma14, ieps14 = toppar.params['nonbonded'][type1]
                if type2 in toppar.params['nb14']:
                    jsigma14, jeps14 = toppar.params['nb14'][type2]
                    jpair    = True
                else:
                    jsigma14, jeps14 = toppar.params['nonbonded'][type2]
                if ipair or jpair:
                    sigma14 = (isigma14 + jsigma14)/2.0
                    eps14   = (ieps14 * jeps14)**0.5
                    dbpairs.append([type1,type2,sigma14,eps14])

    # nbfix
    for nbfix in toppar.params['nbfix']:
        type1, type2 = nbfix
        sigma, eps = toppar.params['nbfix'][type1,type2]
        if type1 in psf.types and type2 in psf.types:
            if not [type1, type2, sigma, eps] in dbnbfix:
                dbnbfix.append([type1,type2,sigma,eps])

    # angletypes
    for angle in toppar.params['angles']:
        type1, type2, type3 = angle
        if all([attype in psf.types for attype in [type1, type2, type3]]):
            th0, cth, S0, Kub = toppar.params['angles'][type1,type2,type3]
            dbangles.append([type1,type2,type3,th0,cth,S0,Kub])

    # dihedraltypes
    for dihedral in toppar.params['dihedrals']:
        type1, type2, type3, type4 = dihedral
        if type1 == type4 == 'X' and all([attype in psf.types for attype in [type2, type3]]):
            for m in toppar.params['dihedrals'][type1, type2, type3, type4]:
                phi, cp, mult = m
                dbdihewilds.append([type1,type2,type3,type4,phi,cp,mult])
        elif all([attype in psf.types for attype in [type1, type2, type3, type4]]):
            for m in toppar.params['dihedrals'][type1, type2, type3, type4]:
                phi, cp, mult = m
                dbdihedrals.append([type1,type2,type3,type4,phi,cp,mult])

    # impropertypes
    for improper in toppar.params['impropers']:
        type1, type2, type3, type4 = improper
        if type2 == type3 == 'X' and all([attype in psf.types for attype in [type1, type4]]):
            q0, cq = toppar.params['impropers'][type1,type2,type3,type4]
            dbimprwilds.append([type1,type2,type3,type4,q0,cq])
        elif all([attype in psf.types for attype in [type1, type2, type3, type4]]):
            q0, cq = toppar.params['impropers'][type1,type2,type3,type4]
            dbimpropers.append([type1,type2,type3,type4,q0,cq])

    # cmaptypes
    for icmap in toppar.params['cmap']:
        if all([attype in psf.types for attype in icmap['atoms']]):
            dbcmap.append(icmap)

    dbbonds.sort()
    dbpairs.sort()
    dbnbfix.sort()
    dbangles.sort()
    dbdihedrals.sort()
    dbdihewilds.sort()
    dbimpropers.sort()
    dbimprwilds.sort()


    # Write parFiles: charmm36.itp
    #------------------------------

    if not os.path.exists('gromacs/toppar'):
        os.makedirs('gromacs/toppar')
    itpFile = open('gromacs/toppar/charmm36.itp', 'w')

    itpFile.write(';;\n')
    itpFile.write(';; Generated by CHARMM-GUI (http://www.charmm-gui.org)\n')
    itpFile.write(';;\n')
    itpFile.write(';; psf2itp.py\n')
    itpFile.write(';;\n')
    itpFile.write(';; Correspondance:\n')
    itpFile.write(';; jul316@lehigh.edu or wonpil@lehigh.edu\n')
    itpFile.write(';;\n')
    itpFile.write(';; CHARMM36 FF in GROMACS format\n')
    itpFile.write(';;\n\n')

    # defaults
    itpFile.write('\n[ defaults ]\n')
    itpFile.write('; nbfunc\tcomb-rule\tgen-pairs\tfudgeLJ\tfudgeQQ\n')
    itpFile.write('1\t2\tyes\t1.0\t1.0\n')

    # atomtypes
    itpFile.write('\n[ atomtypes ]\n')
    itpFile.write('; name\tat.num\tmass\tcharge\tptype\tsigma\tepsilon\t;\tsigma_14\tepsilon_14\n')
    for attype in psf.types:
        mass    = toppar.params['atoms'][attype]['mass']
        charge  = toppar.params['atoms'][attype]['charge']
        element = toppar.params['atoms'][attype]['elem']
        elementNumber = elem2atomNumber[element]
        sigma, eps = toppar.params['nonbonded'][attype]
        if attype in toppar.params['nb14']:
            sigma14, eps14 = toppar.params['nb14'][attype]
            itpFile.write(' %7s %5d %10.4f %10.3f %5s %20.11e %15.6e ; %19.11e %15.6e \n' % (attype, elementNumber, mass, charge, ptype, sigma, eps, sigma14, eps14))
        else:
            itpFile.write(' %7s %5d %10.4f %10.3f %5s %20.11e %15.6e \n' % (attype, elementNumber, mass, charge, ptype, sigma, eps))

    # nbfix
    if len(dbnbfix) > 0:
        itpFile.write('\n[ nonbond_params ]\n')
        itpFile.write('; i\tj\tfunc\tsigma\tepsilon\n')
        for nbfix in dbnbfix:
            type1, type2, sigma, eps = nbfix
            itpFile.write('%7s %7s %5d %18.11e %18.11e \n' % (type1, type2, funcFor14, sigma, eps))

    # bondtypes
    if len(dbbonds) > 0:
        itpFile.write('\n[ bondtypes ]\n')
        itpFile.write('; i\tj\tfunc\tb0\tKb\n')
        for bond in dbbonds:
            type1, type2, b0, Kb = bond
            itpFile.write('%7s %7s %5d %13.6e %13.6e\n' % (type1, type2, funcForBonds, b0, Kb))

    # pairtypes
    #print(dbpairs)
    if len(dbpairs) > 0:
        itpFile.write('\n[ pairtypes ]\n')
        itpFile.write('; i\tj\tfunc\tsigma1-4\tepsilon1-4\n')
        for pair in dbpairs:
            type1, type2, sigma14, eps14 = pair
            itpFile.write('%7s %7s %5d %18.11e %18.11e \n' % (type1, type2, funcFor14, sigma14, eps14))

    # angletypes
    if len(dbangles) > 0:
        itpFile.write('\n[ angletypes ]\n')
        itpFile.write('; i\tj\tk\tfunc\tth0\tcth\tS0\tKub\n')
        for angle in dbangles:
            type1, type2, type3, th0, cth, S0, Kub = angle
            itpFile.write('%7s %7s %7s %5d %14.7e %14.7e %14.7e %14.7e\n' % (type1, type2, type3, funcForAngles, th0, cth, S0, Kub))

    # dihedraltypes
    if len(dbdihedrals) > 0 or len(dbdihewilds) > 0:
        itpFile.write('\n[ dihedraltypes ]\n')
        itpFile.write('; i\tj\tk\tl\tfunc\tphi0\tcp\tmult\n')
        for dihedral in dbdihedrals:
            type1, type2, type3, type4, phi, cp, mult = dihedral
            itpFile.write('%7s %7s %7s %7s %5d %13.6e %13.6e %6d\n' % (type1, type2, type3, type4, funcForDihedrals, phi, cp, mult))
        for dihedral in dbdihewilds:
            type1, type2, type3, type4, phi, cp, mult = dihedral
            itpFile.write('%7s %7s %7s %7s %5d %13.6e %13.6e %6d\n' % (type1, type2, type3, type4, funcForDihedrals, phi, cp, mult))

    # impropertypes
    if len(dbimpropers) > 0 or len(dbimprwilds) > 0:
        itpFile.write('\n[ dihedraltypes ]\n')
        itpFile.write('; i\tj\tk\tl\tfunc\tq0\tcq\n')
        for improper in dbimpropers:
            type1, type2, type3, type4, q0, cq = improper
            itpFile.write('%7s %7s %7s %7s %5d %13.6e %13.6e\n' % (type1, type2, type3, type4, funcForImpropers, q0, cq))
        for improper in dbimprwilds:
            type1, type2, type3, type4, q0, cq = improper
            itpFile.write('%7s %7s %7s %7s %5d %13.6e %13.6e\n' % (type1, type2, type3, type4, funcForImpropers, q0, cq))

    # cmaptypes
    if len(dbcmap) > 0:
        itpFile.write('\n[ cmaptypes ]\n')
        itpFile.write('; i j k l m\n')
        for icmap in dbcmap:
            type1, type2, type3, type4, type5 = icmap['atoms']
            ncmap = icmap['ncmap']
            itpFile.write('%s %s %s %s %s %d %d %d\\\n' % (type1, type2, type3, type4, type5, funcForCmap, ncmap, ncmap))
            for i, icmapdata in enumerate(icmap['data']):
                itpFile.write('%f' % icmapdata)
                if i+1 == len(icmap['data']): itpFile.write('\n\n')
                elif (i+1) % 10 == 0:         itpFile.write('\\\n')
                else:                         itpFile.write(' ')

    itpFile.close()


    # Write itpFiles
    #--------------------

    norest = ['DCLE', 'SOLV']

    # molecule.itp
    for imol, molname in enumerate(psf.mol):
        molatoms     = psf.atoms[imol]
        molbonds     = psf.bonds[imol]
        print(molbonds[0])
        molangles    = sorted(psf.angles[imol], key=lambda x:x[1])
        moldihedrals = sorted(psf.dihedrals[imol], key=lambda x:[x[1], x[2], x[0], x[3]])
        molimpropers = sorted(psf.impropers[imol], key=lambda x:[x[0], x[3], x[1], x[2]])
        molgrps      = psf.grps[imol]
        mollonepairs = psf.lonepairs[imol]
        molcmaps     = psf.cmaps[imol]

        # build 1-4 pairs
        molpairs = []
        for i in range(len(molbonds)):
            for j in molbonds[i]:
                for k in molbonds[j]:
                    if k != i:
                        for l in molbonds[k]:
                            if l != j and l > i:
                                pairpass = False
                                for j2 in molbonds[i]:
                                    if l in molbonds[j2]:
                                        pairpass = True
                                if not pairpass:
                                    if not [i, l] in molpairs:
                                        molpairs.append([i, l])

        # exclusions for lonepair
        molexclusions = []
        for lp in mollonepairs:
            i = lp['atoms'][0]
            j = lp['atoms'][1]
            molexclusions.append([i, j])
            for k in molbonds[j]:
                if k != i:
                    molexclusions.append([i, k])
                    for l in molbonds[k]:
                        if l != j:
                            if lp['atoms'][2] == k and len(lp['atoms']) == 3: lp['atoms'].append(l)
                            molexclusions.append([i, l])
                            for m in molbonds[l]:
                                if m != k:
                                    molexclusions.append([i, m])
                                    molpairs.append([i, m])

        if molname in psf.solv:
            if os.path.isfile('gromacs/toppar/TIP3.itp'): continue
            itpFile = open('gromacs/toppar/TIP3.itp', 'w')
        else:
            itpFile = open('gromacs/toppar/'+molname+'.itp', 'w')

        nrexcl = 1
        if len(molbonds) > 1:
            nrexcl = 2
        if len(moldihedrals) > 0:
            nrexcl = 3

        itpFile.write(';;\n')
        itpFile.write(';; Generated by CHARMM-GUI (http://www.charmm-gui.org)\n')
        itpFile.write(';;\n')
        itpFile.write(';; psf2itp.py\n')
        itpFile.write(';;\n')
        itpFile.write(';; Correspondance:\n')
        itpFile.write(';; jul316@lehigh.edu or wonpil@lehigh.edu\n')
        itpFile.write(';;\n')
        if molname in psf.solv:
            itpFile.write(';; GROMACS topology file for TIP3\n')
        else:
            itpFile.write(';; GROMACS topology file for %s\n' % molname.upper())
        itpFile.write(';;\n\n')

        itpFile.write('\n[ moleculetype ]\n')
        itpFile.write('; name\tnrexcl\n')
        if molname in psf.solv:
            itpFile.write('TIP3\t %5d\n' % nrexcl)
        else:
            itpFile.write('%s\t %5d\n' % (molname.upper(), nrexcl))

        # atoms
        itpFile.write('\n[ atoms ]\n')
        itpFile.write('; nr\ttype\tresnr\tresidu\tatom\tcgnr\tcharge\tmass\n')
        qtot = 0.0
        ion = True
        for i,atom in enumerate(molatoms):
            attype = atom['type']
            resnr  = atom['resnr']
            residu = atom['residu']
            iatom  = atom['atom']
            charge = atom['charge']
            mass   = atom['mass']
            qtot  += charge
            if not residu in toppar.wationlib: ion = False
            try:
                group = molgrps.index(i+1) + 1
            except:
                None
            itpFile.write(' %5d %10s %6s %8s %6s %6d %10.3f %10.4f   ; qtot %6.3f\n' % (i+1, attype, resnr, residu, iatom, i+1, charge, mass, qtot))

        if molname not in psf.solv:
            # bonds
            if len(molbonds) > 0:
                itpFile.write('\n[ bonds ]\n')
                itpFile.write('; ai\taj\tfunct\tb0\tKb\n')
                for i, bond in enumerate(molbonds):
                    bond.sort()
                    for j in bond:
                        if j > i:
                            atom1 = i + 1
                            atom2 = j + 1
                            itpFile.write('%5d %5d %5d\n' % (atom1, atom2, funcForBonds))

            # pairs
            if len(molpairs) > 0:
                itpFile.write('\n[ pairs ]\n')
                itpFile.write('; ai\taj\tfunct\tc6\tc12\n')
                molpairs.sort()
                for i in range(len(molpairs)):
                    atom1 = molpairs[i][0] + 1
                    atom4 = molpairs[i][1] + 1
                    itpFile.write('%5d %5d %5d \n' % (atom1, atom4, funcFor14))

            # angles
            if len(molangles) > 0:
                itpFile.write('\n[ angles ] \n')
                itpFile.write('; ai\taj\tak\tfunct\tth0\tcth\tS0\tKub\n')
                for angle in molangles:
                    atom1, atom2, atom3 = angle
                    itpFile.write('%5d %5d %5d %5d\n' % (atom1, atom2, atom3, funcForAngles))

            # dihedrals
            if len(moldihedrals) > 0:
                itpFile.write('\n[ dihedrals ]\n')
                itpFile.write('; ai\taj\tak\tal\tfunct\tphi0\tcp\tmult\n')
                for dihedral in moldihedrals:
                    atom1, atom2, atom3, atom4 = dihedral
                    itpFile.write('%5d %5d %5d %5d %5d\n' % (atom1, atom2, atom3, atom4, funcForDihedrals))

            # impropers
            if len(molimpropers) > 0:
                itpFile.write('\n[ dihedrals ]\n')
                itpFile.write('; ai\taj\tak\tal\tfunct\tq0\tcq\n')
                for improper in molimpropers:
                    atom1, atom2, atom3, atom4 = improper
                    itpFile.write('%5d %5d %5d %5d %5d\n' % (atom1, atom2, atom3, atom4, funcForImpropers))

            # cmaps
            if len(molcmaps) > 0:
                itpFile.write('\n[ cmap ] \n')
                itpFile.write('; ai\taj\tak\tal\tam\tfunct\n')
                molcmaps.sort()
                for icmap in molcmaps:
                    atom1, atom2, atom3, atom4, atom5 = icmap
                    itpFile.write('%5d %5d %5d %5d %5d %5d\n' % (atom1, atom2, atom3, atom4, atom5, funcForCmap))

            if len(mollonepairs) > 0:
                itpFile.write('\n[ virtual_sites3 ]\n')
                itpFile.write('; Site   from               funct theta d\n')
                for lp in mollonepairs:
                    atom1 = lp['atoms'][0] + 1
                    atom2 = lp['atoms'][1] + 1
                    atom3 = lp['atoms'][2] + 1
                    atom4 = lp['atoms'][3] + 1
                    theta = 180.0
                    d = lp['d']
                    itpFile.write("%5d %5d %5d %5d %5d %8.2f %8.3f\n" % (atom1, atom2, atom3, atom4, funcForLonepairs, theta, d))

            if len(molexclusions) > 0:
                itpFile.write('\n[ exclusions ]\n')
                itpFile.write(';   ai    aj\n')
                for iexcl in molexclusions:
                    atom1 = iexcl[0] + 1
                    atom2 = iexcl[1] + 1
                    itpFile.write("%5d %5d %5d\n" % (atom1, atom2, funcForExclusions))

            if not ion and not molname in norest:
               # position or dihedral restraints for proteins, carbohydrates, and ligands
               itpFile.write('\n#ifdef REST_ON\n')
               itpFile.write('#include "../restraints/%s_rest.itp"\n' % molname.upper())
               itpFile.write('#endif\n')

        else:
            try:
                b0_1 = toppar.params['bonds']['OT','HT'][0]
                b0_2 = toppar.params['bonds']['HT','HT'][0]
            except:
                b0_1 = toppar.params['bonds']['HT','OT'][0]
                b0_2 = toppar.params['bonds']['HT','HT'][0]

            itpFile.write('\n[ settles ]\n')
            itpFile.write('; i\tj\tfunct\tlength\n')
            itpFile.write('1\t1\t%13.6e\t%13.6e\n' % (b0_1, b0_2))

            itpFile.write('\n[ exclusions ]\n')
            itpFile.write('1 2 3\n')
            itpFile.write('2 1 3\n')
            itpFile.write('3 1 2\n')

        itpFile.close()


    # Write indexFile
    #--------------------

    # index.ndx

    ndxFile = open('gromacs/index.ndx', 'w')

    for i in range(3):
        if len(psf.memb) > 0 or len(psf.glip) > 0:
            if len(psf.ndx[i]) > 0:
                if i == 0: ndxFile.write('\n\n[ PROT ]\n')
                if i == 1: ndxFile.write('\n\n[ MEMB ]\n')
                if i == 2: ndxFile.write('\n\n[ SOL_ION ]\n')
                for j, iatom in enumerate(psf.ndx[i]):
                    ndxFile.write('%5d ' % iatom)
                    if int(j + 1) % 15 == 0: ndxFile.write('\n')
        else:
            if len(psf.ndx[i]) > 0:
                if i == 0: ndxFile.write('\n\n[ PROT ]\n')
                if i == 2: ndxFile.write('\n\n[ SOL_ION ]\n')
                for j, iatom in enumerate(psf.ndx[i]):
                    ndxFile.write('%5d ' % iatom)
                    if int(j + 1) % 15 == 0: ndxFile.write('\n')
                    j += 1

    ndxFile.write('\n\n')
    ndxFile.close()


    # Write topFile
    #--------------------

    # topol.top

    topFile = open('gromacs/topol.top', 'w')

    topFile.write(';;\n')
    topFile.write(';; Generated by CHARMM-GUI (http://www.charmm-gui.org)\n')
    topFile.write(';;\n')
    topFile.write(';; psf2itp.py\n')
    topFile.write(';;\n')
    topFile.write(';; Correspondance:\n')
    topFile.write(';; jul316@lehigh.edu or wonpil@lehigh.edu\n')
    topFile.write(';;\n')
    topFile.write(';; The main GROMACS topology file\n')
    topFile.write(';;\n\n')

    topFile.write('; Include forcefield parameters\n')
    topFile.write('#include "toppar/charmm36.itp"\n')
    for molname in psf.mol:
        if molname in psf.solv: continue
        topFile.write('#include "toppar/%s.itp"\n' % molname.upper())
    if psf.solv: topFile.write('#include "toppar/TIP3.itp"\n')

    topFile.write('\n[ system ]\n')
    topFile.write('; Name\n')
    topFile.write('Title\n')

    topFile.write('\n[ molecules ]\n')
    topFile.write('; Compound\t#mols\n')
    for molname in psf.mol:
        if molname in psf.solv:
            topFile.write('TIP3  \t%12d\n' % psf.molNumber[molname])
        else:
            topFile.write('%-6s\t%12d\n' % (molname, psf.molNumber[molname]))

    topFile.close()

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('top', metavar='toppar.str', help='input CHARMM toppar stream file')
    parser.add_argument('psf', metavar='psfFile', help='input CHARMM PSF file')
    parser.add_argument('-hmr', dest='hmr', default=False, action='store_true')
    args = parser.parse_args()

    # Read topparFiles
    toppar = TOPPAR(args.top)
    toppar.readToppar()

    # Read psfFile
    psf = PSF(args.psf)
    psf.readPSF(toppar)
    if args.hmr: psf.HydrogenMassRepartition(toppar)

    # Write itpFiles
    write_itp(toppar, psf)

